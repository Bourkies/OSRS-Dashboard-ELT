# ---------------------------------------------------------------------- #
#               EXAMPLE CONFIGURATION - RENAME TO .toml                  #
# ---------------------------------------------------------------------- #
# This file contains all the main configurations for the ETL pipeline.
# Copy this to 'config.toml' and edit it to your needs.

#-----------------------------------------------------------------------
# General Settings
#-----------------------------------------------------------------------
[general]
project_name = "OSRS Discord Dashboard ELT"

[logging]
  level = "DEBUG" # TRACE DEBUG INFO SUCCESS WARNING ERROR CRITICAL
  file_path = "logs/app.log"
  rotation = "10 MB"
  retention = "7 days"
  format = "{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name: <10.10}:{function: <10.10}:{line: <4} | {message}"

#-----------------------------------------------------------------------
# ETL Runner Settings
#-----------------------------------------------------------------------
# Use these switches to enable or disable parts of the pipeline.
[etl_runner]
# Determines if the script that posts historical PBs to Discord should run.
run_post_pbs_script = true

#-----------------------------------------------------------------------
# Log and Summary Cleanup Settings
#-----------------------------------------------------------------------
# Automatically deletes old log and summary files.
[cleanup_settings]
# Number of days to keep log and summary files. Set to 0 to disable cleanup.
log_retention_days = 30

#-----------------------------------------------------------------------
# File Path Settings
#-----------------------------------------------------------------------
# These files contain historical records and dashboard configuration settings.
# They are located in the 'src' directory.
[historical_data]
personal_bests_file = "historical_personal_bests.toml"
collection_log_file = "historical_collection_logs.toml"

#-----------------------------------------------------------------------
# fetch days Settings
#-----------------------------------------------------------------------
# Controls the time range for fetching new data from Discord.
[time_settings]
# 'auto' mode fetches data since the last run.
# 'custom' mode uses the fixed dates below.
mode = "auto"

# In 'auto' mode, how many minutes to overlap with the previous run to avoid missing messages.
start_time_overlap_minutes = 10
# In 'auto' mode, how many minutes to wait before fetching to ensure messages are fully processed by Discord.
end_time_offset_minutes = 1
# In 'auto' mode, if no previous data exists, how many days back to fetch.
max_lookback_days = 90

[custom_time_range]
# Only used if time_settings.mode is 'custom'. Format: "YYYY-MM-DD HH:MM"
custom_start_date = "2023-01-01 00:00"
custom_end_date = "2023-01-31 23:59"

#-----------------------------------------------------------------------
# Username Mapping Settings
#-----------------------------------------------------------------------
# This section allows you to combine multiple usernames into a single target username.
# This is useful for tracking players who have changed their names.
# Each rule applies to a specific time range. You can have multiple rules for the same name
# to handle name trading back and forth.
#
# - target_username: The final username to be displayed in reports.
# - source_usernames: A list of old usernames to be mapped.
# - start_date / end_date: Optional. Format "YYYY-MM-DD HH:MM".
#   - Time is in UTC
#   - If only start_date is given, it applies from that date onwards.
#   - If only end_date is given, it applies until that date.
#   - If both are given, it applies within that specific range.
#   - If neither is given, it applies to all time.
#
# IMPORTANT: If mapping rules overlap for the same source username, the rule that appears
# LATER in this list will take precedence.

[username_mapping]
rules = [
  # Example 1: "bee" and "mark" are always mapped to "Mace".
  # { target_username = "Mace", source_usernames = ["bee", "mark"] },

  # Example 2: "PlayerA" was known as "OldNameA" before 2025-03-01.
  # { target_username = "PlayerA", source_usernames = ["OldNameA"], end_date = "2025-03-01 00:00" },

  # Example 3: "PlayerB" was known as "OldNameB" starting from 2025-05-15.
  # { target_username = "PlayerB", source_usernames = ["OldNameB"], start_date = "2025-05-15 00:00" },

  # Example 4: A specific name change for a limited time.
  # { target_username = "TempUser", source_usernames = ["MainUser"], start_date = "2025-06-01 00:00", end_date = "2025-06-15 00:00" }

  # Rule start
  { target_username = "zezima", source_usernames = ["old zezima"] },

]

#-----------------------------------------------------------------------
# Item Value Overrides
#-----------------------------------------------------------------------
# Used in the transform step (3_transform_data.py) to assign a value
# to items that are parsed without one, such as from "Raid Loot" broadcasts.
# The key is the exact item name, and the value is the integer price.
# Underscores can be used in numbers for readability.
[item_value_overrides]
# Updated 2025 07 02
# CoX
"Dexterous prayer scroll" = 16_000_000
"Arcane prayer scroll" = 3_230_000
"Twisted buckler" = 15_500_000
"Dragon hunter crossbow" = 43_260_000
"Dinh's bulwark" = 13_570_000
"Ancestral hat" = 68_038_000
"Ancestral robe top" = 173_830_000
"Ancestral robe bottom" = 133_610_000
"Dragon claws" = 60_940_000
"Elder maul" = 125_870_000
"Kodai insignia" = 99_070_000
"Twisted bow" = 1_486_480_000

# ToB
"Avernic defender hilt" = 46_990_000
"Ghrazi rapier" = 36_510_000
"Sanguinesti staff (uncharged)" = 53_500_000
"Justiciar faceguard" = 10_320_000
"Justiciar chestguard" = 11_460_000
"Justiciar legguards" = 8_610_000
"Scythe of vitur (uncharged)" = 1_642_470_000

# ToA
"Osmumten's fang" = 21_670_000
"Lightbearer" = 4_970_000
"Elidinis' ward" = 3_620_000
"Masori mask" = 5_090_000
"Masori body" = 34_740_000
"Masori chaps" = 25_080_000
"Tumeken's shadow (uncharged)" = 1_031_620_000

# idiots getting lured for max cash
# didnt feel like editing the code so creates an item to attach to it
# This will probably cause issues down the line, future issue, good for now!
"an extraordinary amount of loot" = 2_147_483_647


#-----------------------------------------------------------------------
# Parse settings
#-----------------------------------------------------------------------
# Controls how the parsing script operates.
[parse_settings]
# 'new' mode processes only new and previously unparsed logs.
# 'all' mode clears all parsed data and re-processes everything from the raw logs.
mode = "new"
# parse definitions located further down


#-----------------------------------------------------------------------
# Transform Setttings
#-----------------------------------------------------------------------
# --- Dashboard Settings ---
# These settings control the data transformations for the dashboard.
[dashboard_settings]
week_start_day = "Monday"
custom_lookback_days = 14
top_drops_limit = 50


[dashboard_settings.collection_log]
source_types = ["Collection Log", "Valuable Drop", "Raid Loot", "Clue Scroll Item"]
deduplication_type = "Collection Log"


[dashboard_settings.personal_bests]
broadcast_type = "Personal Best"
# How close in seconds two times must be to be considered identical (e.g., 0.6 for 59.4s and 1:00.0)
pb_time_similarity_threshold_seconds = 0.6
# How close in time (seconds) two identical PBs must be to be grouped as a single record.
pb_grouping_window_seconds = 15
# If true, all players who match the best time will be listed as holders.
# If false, only the first player/group to achieve the time will hold the record.
allow_multiple_holders_on_match = false

[dashboard_settings.recent_achievements]
source_types = ["Level Up", "Quest", "Diary", "Combat Task", "Combat Achievement Tier", "Pet", "HC Life Lost"]
limit_per_type = 15

# --- Generic Leaderboard Reports ---
# Used for creating summary tables with counts and values per player.
# The aggregations can be defined as an inline table for readability.
[[dashboard_settings.leaderboard_reports]]
report_name = "valuable_drops_summary"
source_table = "clan_broadcasts"
broadcast_type = ["Valuable Drop", "Raid Loot", "Clue Scroll Item"] # can use a single or a list of strings to aggergate from mutiple broadcast types.
group_by_column = "Username"
aggregations = { Count = "Username", Value = "Item_Value" }

[[dashboard_settings.leaderboard_reports]]
report_name = "pvp_kills_summary"
source_table = "clan_broadcasts"
broadcast_type = "PvP Kill"
group_by_column = "Username"
aggregations = { Count = "Username", Value = "Item_Value" }

[[dashboard_settings.leaderboard_reports]]
report_name = "pvp_deaths_summary"
source_table = "clan_broadcasts"
broadcast_type = "PvP Death"
group_by_column = "Username"
aggregations = { Count = "Username", Value = "Item_Value" }

[[dashboard_settings.leaderboard_reports]]
report_name = "kicked_by_player_summary"
source_table = "clan_broadcasts"
broadcast_type = "Clan Expelled"
group_by_column = "Username"
aggregations = { Count = "Username" }

[[dashboard_settings.leaderboard_reports]]
report_name = "kicker_summary"
source_table = "clan_broadcasts"
broadcast_type = "Clan Expelled"
group_by_column = "Action_By"
aggregations = { Count = "Action_By" }

[[dashboard_settings.leaderboard_reports]]
report_name = "stolen_whips_summary"
source_table = "clan_broadcasts"
broadcast_type = "Valuable Drop"
item_name_filter = "Abyssal whip"
group_by_column = "Username"
aggregations = { Count = "Username", Value = "Item_Value" }

[[dashboard_settings.leaderboard_reports]]
report_name = "menaces_111_summary"
source_table = "chat"
search_phrases = ["111"]
group_by_column = "Username"
aggregations = { Count = "Content" }

[[dashboard_settings.leaderboard_reports]]
report_name = "big_gzers_summary"
source_table = "chat"
search_phrases = ["gz", "grats", "gratz"]
group_by_column = "Username"
aggregations = { Count = "Content" }

[[dashboard_settings.leaderboard_reports]]
report_name = "cya_hick_crew_summary"
source_table = "chat"
search_phrases = ["cya hick"]
group_by_column = "Username"
aggregations = { Count = "Content" }


# --- Detailed History Reports ---
# Used for creating tables of individual events for each time period.
[[dashboard_settings.detailed_reports]]
report_name_prefix = "valuable_drops_detail"
broadcast_types = ["Valuable Drop", "Clue Scroll Item", "Raid Loot"]

[[dashboard_settings.detailed_reports]]
report_name_prefix = "pvp_kills_detail"
broadcast_types = ["PvP Kill"]

[[dashboard_settings.detailed_reports]]
report_name_prefix = "pvp_deaths_detail"
broadcast_types = ["PvP Death"]


# --- Timeseries Reports ---
# Used for generating data for the line/area charts.
[[dashboard_settings.timeseries_reports]]
report_name = "valuable_drops_timeseries"
broadcast_type = "Valuable Drop"
frequencies = ["6h", "D", "W"]

[[dashboard_settings.timeseries_reports]]
report_name = "pvp_kills_timeseries"
broadcast_type = "PvP Kill"
frequencies = ["6h", "D", "W"]

[[dashboard_settings.timeseries_reports]]
report_name = "pvp_deaths_timeseries"
broadcast_type = "PvP Death"
frequencies = ["6h", "D", "W"]

#-----------------------------------------------------------------------
# Database Locations
#-----------------------------------------------------------------------
[databases]
# These paths are relative to the project root directory
raw_db_uri = "sqlite:///data/raw_data.db"
parsed_db_uri = "sqlite:///data/parsed_data.db"
optimised_db_uri = "sqlite:///data/optimised_data.db"


#-----------------------------------------------------------------------
# Database Schema Definition
#-----------------------------------------------------------------------

[database_schema]
# Added 'raw_log_id' to link back to the original message.
clan_broadcasts = { raw_log_id = "INTEGER", Timestamp = "TEXT", Content = "TEXT", Username = "TEXT", Broadcast_Type = "TEXT", Item_Name = "TEXT", Item_Value = "BIGINT", Collection_Log_Progress = "TEXT", Skill = "TEXT", Task_Name = "TEXT", New_Level = "INTEGER", Tier = "TEXT", PB_Time = "TEXT", Source_Mob = "TEXT", Opponent = "TEXT", Pet_Name = "TEXT", Pet_KC = "INTEGER", Pet_KC_Type = "TEXT", Action_By = "TEXT", New_Group_Lives = "TEXT" }
chat = { raw_log_id = "INTEGER", Timestamp = "TEXT", MessageType = "TEXT", Rank = "TEXT", Status = "TEXT", Username = "TEXT", Content = "TEXT" }
unparsed_logs = { raw_log_id = "INTEGER", timestamp = "TEXT", raw_content = "TEXT", failure_reason = "TEXT" }


#-----------------------------------------------------------------------
# Message Parsing Patterns
#-----------------------------------------------------------------------
[patterns]

# --- Clan Chat PATTERN GROUPS ---

[patterns.Chat]
type = "chat"
regex = '''^<:(\w+):\d+>(?:<:(\w+):\d+>)?\s*\*\*(.*?)\*\*:\s*(.*)'''
columns = ["Rank", "Status", "Username", "Content"]

# --- BROADCAST PATTERN GROUPS ---

[patterns.valuable_drop]
broadcast_type = "Valuable Drop"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+received a drop: (.*?)\s+\((\d{1,3}(?:,\d{3})*|\d+) coins\) from (.*?)\.?$''', columns = ["Username", "Item_Name", "Item_Value", "Source_Mob"], required_columns = ["Username", "Item_Name", "Item_Value", "Source_Mob"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+received a drop: (.*?)\s+\((\d{1,3}(?:,\d{3})*|\d+) coins\)\.?$''', columns = ["Username", "Item_Name", "Item_Value"], required_columns = ["Username", "Item_Name", "Item_Value"] },
    { regex = '''^(.+?)\s+received a rare drop: (.*)$''', columns = ["Username", "Item_Name"], required_columns = ["Username", "Item_Name"] },
    { regex = '''^(.+?)\s+received an item: (.*)$''', columns = ["Username", "Item_Name"], required_columns = ["Username", "Item_Name"] }
]

[patterns.clue_scroll]
broadcast_type = "Clue Scroll Item"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+received a clue item: (.*?)\s+\((\d{1,3}(?:,\d{3})*|\d+) coins\)\.?$''', columns = ["Username", "Item_Name", "Item_Value"], required_columns = ["Username", "Item_Name", "Item_Value"] }
]

[patterns.collection_log]
broadcast_type = "Collection Log"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+received a new collection log item: (.*?)\s+\((\d+/\d+)\)$''', columns = ["Username", "Item_Name", "Collection_Log_Progress"], required_columns = ["Username", "Item_Name", "Collection_Log_Progress"] }
]

[patterns.raid_loot]
broadcast_type = "Raid Loot"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+received special loot from a raid: (.*?)\.?$''', columns = ["Username", "Item_Name"], required_columns = ["Username", "Item_Name"] }
]

[patterns.pet]
broadcast_type = "Pet"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has a funny feeling.*?:\s+(.*?)\s+at\s+([\d,]+)\s+([\w\s]+)\.$''', columns = ["Username", "Pet_Name", "Pet_KC", "Pet_KC_Type"], required_columns = ["Username", "Pet_Name", "Pet_KC", "Pet_KC_Type"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+feels something weird.*?:\s+(.*?)\s+at\s+([\d,]+)\s+([\w\s]+)\.$''', columns = ["Username", "Pet_Name", "Pet_KC", "Pet_KC_Type"], required_columns = ["Username", "Pet_Name", "Pet_KC", "Pet_KC_Type"] },
	{ regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has a funny feeling.*?:\s+(.*?)\s+at\s+([\d,]+)\s+([\w\s]+?)\s+\(.*$''', columns = ["Username", "Pet_Name", "Pet_KC", "Pet_KC_Type"], required_columns = ["Username", "Pet_Name", "Pet_KC", "Pet_KC_Type"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+feels like (?:.*?) acquired something special:\s*(.+)$''', columns = ["Username", "Pet_Name"], required_columns = ["Username", "Pet_Name"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has a funny feeling like \S+ being followed:\s+(.*?)\.?$''', columns = ["Username", "Pet_Name"], required_columns = ["Username", "Pet_Name"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has a funny feeling like \S+ would have been followed:\s+(.*?)\.?$''', columns = ["Username", "Pet_Name"], required_columns = ["Username", "Pet_Name"] },
]

[patterns.level_up]
broadcast_type = "Level Up"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has reached ([\w\s]+) level (\d+)\.?$''', columns = ["Username", "Skill", "New_Level"], required_columns = ["Username", "Skill", "New_Level"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has reached the highest possible (combat) level of (\d+)!$''', columns = ["Username", "Skill", "New_Level"], required_columns = ["Username", "Skill", "New_Level"] }
]

[patterns.total_level]
broadcast_type = "Total Level"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has reached a total level of (\d+)\.?$''', columns = ["Username", "New_Level"], required_columns = ["Username", "New_Level"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has reached the highest possible total level of (\d+)\!?$''', columns = ["Username", "New_Level"], required_columns = ["Username", "New_Level"] }
]

[patterns.xp_milestone]
broadcast_type = "XP Milestone"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has reached ([\d,]+) XP in ([\w\s]+)\.?$''', columns = ["Username", "New_Level", "Skill"], required_columns = ["Username", "New_Level", "Skill"] }
]

[patterns.quest]
broadcast_type = "Quest"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has completed a quest: (.*?)\.?$''', columns = ["Username", "Task_Name"], required_columns = ["Username", "Task_Name"] }
]

[patterns.diary]
broadcast_type = "Diary"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has completed the (.*?) (.*?) diary\.$''', columns = ["Username", "Tier", "Task_Name"], required_columns = ["Username", "Tier", "Task_Name"] }
]

[patterns.combat_task]
broadcast_type = "Combat Task"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has completed (?:a|an) (.*?) combat task: (.*?)\.?$''', columns = ["Username", "Tier", "Task_Name"], required_columns = ["Username", "Tier", "Task_Name"] }
]

[patterns.personal_best]
broadcast_type = "Personal Best"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has achieved a new (.*?) personal best:\s+([\d:.]+)$''', columns = ["Username", "Task_Name", "PB_Time"], required_columns = ["Username", "Task_Name", "PB_Time"] }
]

[patterns.pvp_kill]
broadcast_type = "PvP Kill"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has defeated (.*?) and received \((\d{1,3}(?:,\d{3})*|\d+) coins\) worth of loot!(.*)$''', columns = ["Username", "Opponent", "Item_Value", "_"], required_columns = ["Username", "Opponent", "Item_Value"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has defeated (.*?), causing (.*?) to lose \((\d{1,3}(?:,\d{3})*|\d+) coins\) worth of loot!(.*)$''', columns = ["Username", "Opponent", "_", "Item_Value", "_"], required_columns = ["Username", "Opponent", "Item_Value"] },
]

[patterns.pvp_death]
broadcast_type = "PvP Death"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has been defeated by (.*?) in The Wilderness and lost \((\d{1,3}(?:,\d{3})*|\d+) coins\) worth of loot(.*)$''', columns = ["Username", "Opponent", "Item_Value", "_"], required_columns = ["Username", "Opponent", "Item_Value"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has been defeated by (.*?) in The Wilderness(.*)$''', columns = ["Username", "Opponent", "_"], required_columns = ["Username", "Opponent"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has been defeated by (.*?) and lost \((\d{1,3}(?:,\d{3})*|\d+) coins\) worth of loot\.$''', columns = ["Username", "Opponent", "Item_Value"], required_columns = ["Username", "Opponent", "Item_Value"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has been defeated by (.*?) and lost (an extraordinary amount of loot)\.$''', columns = ["Username", "Opponent", "Item_Name"], required_columns = ["Username", "Opponent", "Item_Name"] },
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has been defeated by (.*?)\.$''', columns = ["Username", "Opponent"], required_columns = ["Username", "Opponent"] },
]

[patterns.combat_achievement_tier]
broadcast_type = "Combat Achievement Tier"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has unlocked the (.*?) tier of rewards from Combat Achievements!$''', columns = ["Username", "Tier"], required_columns = ["Username", "Tier"] }
]

[patterns.clan_invite]
broadcast_type = "Clan Invite"
variants = [
    { regex = '''^(?:<:\w+:\d+>){0,2}\s*(.+?)\s+has been invited into the clan by (.*?)\.?$''', columns = ["Username", "Action_By"], required_columns = ["Username", "Action_By"] }
]

[patterns.clan_expelled]
broadcast_type = "Clan Expelled"
variants = [
    { regex = '''^(.+?)\s+has expelled (.+?) from the clan\.?$''', columns = ["Action_By", "Username"], required_columns = ["Action_By", "Username"] }
]

[patterns.clan_left]
broadcast_type = "Clan Left"
variants = [
    { regex = '''^(.+?)\s+has left the clan\.?$''', columns = ["Username"], required_columns = ["Username"] }
]

[patterns.hc_life_lost]
broadcast_type = "HC Life Lost"
variants = [
    { regex = '''^(.+?)\s+has died and lost a life\. (.*?) group has .*?(\d+/\d+) lives left\.$''', columns = ["Username", "_", "New_Group_Lives"], required_columns = ["Username", "New_Group_Lives"] },
    { regex = '''^(.+?)\s+has died and lost their Hardcore Ironman status\.$''', columns = ["Username"], required_columns = ["Username"] },
]

[patterns.clan_coffer_deposit]
broadcast_type = "Clan Coffer Deposit"
variants = [
    { regex = '''^(.+?)\s+has deposited ([\d,]+) coins into the coffer\.$''', columns = ["Username", "Item_Value"], required_columns = ["Username", "Item_Value"] },
]

[patterns.clan_coffer_withdraw]
broadcast_type = "Clan Coffer Withdraw"
variants = [
    { regex = '''^(.+?)\s+has withdrawn ([\d,]+) coins from the coffer\.$''', columns = ["Username", "Item_Value"], required_columns = ["Username", "Item_Value"] }
]

# Bin grouop for tossing out lines 
[patterns.bin]
broadcast_type = "Bin"
variants = [
    { regex = '''^(.+?)\s+received an item: Infernal cape$''', columns = ["Username"], required_columns = ["Username"] },
    { regex = '''^(.+?)\s+has deposited one coin into the coffer\.$''', columns = ["Username"], required_columns = ["Username"] },
    { regex = '''^<@728615641245941770>$''', columns = [], required_columns = [] },
    { regex = '''^<@192497559581884416> ?''', columns = [], required_columns = [] },
]