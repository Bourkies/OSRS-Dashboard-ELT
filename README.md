# OSRS Dashboard ET Pipeline

This project contains the ET (Extract, Transform) pipeline for a custom clan dashboard. It is designed to be run as a Docker container, fetching data from Discord, processing it with a highly configurable Python script, and preparing it for use in a dashboard.

This pipeline is intended to be deployed on a server (like a Raspberry Pi) and run on a schedule (e.g., using a cron job).
Please note AI has been extensively used in the creation of this project

## Features

* **Discord Integration**: Fetches message history from a specified Discord channel.
* **Advanced Regex Parsing**: Uses TOML configuration files to define complex regex patterns for parsing different message types (e.g., chat, drops, achievements).
* **Local Database**: Uses a local SQLite database to store all raw, parsed, and transformed data, keeping the setup simple and self-contained.
* **Automated Username & Record Management**:
    * Combine multiple historical usernames into a single current name.
    * Blacklist specific personal bests (or all PBs for a user) to maintain leaderboard integrity.
* **Robust Deployment**: Designed to run in a Docker container with a clean, repeatable setup process.
* **Simple Updates**: A `git pull` and `docker-compose build` is all that's needed to deploy new code without affecting your data or configurations.

## Core Dependency: RuneLite Plugin

This script is specifically designed to parse messages generated by the [**Clan Chat Webhook**](https://runelite.net/plugin-hub/show/clan-chat-webhook) plugin for the RuneLite client.

**This is a hard requirement.** For the parsing to work correctly, you must:

1.  Install the "Clan Chat Webhook" plugin from the RuneLite Plugin Hub.
2.  Configure the plugin to send messages to a specific webhook in your Discord server.
3.  The Discord channel that this script reads from (specified in your `secrets.toml`) **should exclusively contain messages from this webhook.** Other chat or bot messages in this channel will cause parsing errors.

---

## Licensing

The source code of this project is licensed under the **MIT License**. You can find a copy of the license in the [LICENSE.md](LICENSE.md) file.

### Image and Asset Licensing

Please note that this project may include images and other assets sourced from the [Old School RuneScape Wiki](https://oldschool.runescape.wiki/). These assets are the copyright of Jagex Ltd.

The OSRS Wiki uses these assets under a specific license, typically the **Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License (CC BY-NC-SA 3.0)**.

This means:
*   You **must provide attribution** to the OSRS Wiki if you use these images.
*   You **may not use these images for commercial purposes**.

For detailed attribution and a list of assets used, please see the [ATTRIBUTIONS.md](ATTRIBUTIONS.md) file.

---
## Project Structure

The project is organized to separate the core application code from user-generated data and private configurations.

* **/src**: Contains all Python source code and the `.example.toml` configuration templates. This is the code that gets updated via `git pull`.
* **/data**: (Git Ignored) Stores the local SQLite databases. This directory is mounted as a Docker volume to persist data across container runs.
* **/images**: (Git Tracked) Stores image assets used for Discord embeds. This directory is copied into the Docker image during the build process.
* **/logs**: (Git Ignored) Contains detailed log files for each script run. Also mounted as a Docker volume.
* **/summaries**: (Git Ignored) Contains summary text files for each script run. Also mounted as a Docker volume.
* `Dockerfile`: Instructions to build the ETL Docker image.
.dockerignore: Specifies files to exclude from the Docker build context.
* `.gitignore`: Specifies which files and directories Git should ignore, protecting your data and secrets.

---

## Deployment & Setup on a Server (e.g., Raspberry Pi)

Follow these steps to set up and run the ETL pipeline.

### Prerequisites

* [Git](https://git-scm.com/downloads/)
* [Docker and Docker Compose](https://docs.docker.com/engine/install/) (Docker Desktop for Windows/Mac includes Compose)

### 1. Clone the Repository

Clone this repository onto your server into a folder of your choosing. This folder will be your project root.

```bash
git clone <your-github-repo-url> <your-project-folder-name>
cd <your-project-folder-name>
```

### 2. Create Persistent Directories

The `data`, `logs`, and `summaries` directories are intentionally excluded from the Git repository. You need to create them manually in the project root on your server the first time. This ensures that your local data is never accidentally deleted or overwritten by `git` commands. The `images` directory, however, is tracked by Git and will be created automatically when you clone the repository.

```bash
mkdir data
mkdir logs
mkdir summaries
```

### 3. Configure Your Environment

Your secrets and configurations are kept out of Git for security and flexibility. You will create your local configs by copying the provided templates.

1.  Navigate to the `src` directory: `cd src`
2.  Copy the example files to create your local configuration:
    ```bash
    cp secrets.example.toml secrets.toml
    cp config.example.toml config.toml
    cp historical_collection_logs.example.toml historical_collection_logs.toml
    cp historical_personal_bests.example.toml historical_personal_bests.toml
    ```
3.  Open each of the new `.toml` files (e.g., `nano secrets.toml`) and fill in your actual values. This is where you'll add your Discord bot token, channel IDs, webhook URL, username mappings, and historical data.

### 4. Build the Docker Image

From the project's root directory, use Docker Compose to build the service image. This command reads your `docker-compose.yml` file and builds the image according to its specifications.

```bash
docker-compose build
```

---

## Running the ETL

### Manual Run

You can trigger a single ETL run at any time with the following command from your project root. This is great for testing.

```bash
docker-compose run --rm etl
```

### Automating with Cron

To run the pipeline automatically, you can create a cron job.

1.  Open the cron table for editing: `crontab -e`
2.  Add a line to define the schedule. This example runs the ETL every 15 minutes:
    ```crontab
    */15 * * * * cd /path/to/your/<your-project-folder-name> && docker-compose run --rm etl >> /path/to/your/<your-project-folder-name>/logs/cron.log 2>&1
    ```
    **Important:**
    * Replace `/path/to/your/<your-project-folder-name>` with the actual absolute path to your project.
    * The `>> ... 2>&1` part redirects all output to a `cron.log` file, which is useful for debugging.

---

## Updating the Pipeline

This workflow makes updates incredibly simple.

1.  **Pull the latest code** from your GitHub repository:
    ```bash
    cd /path/to/your/<your-project-folder-name>
    git pull origin main
    ```
2.  **Rebuild the Docker image** with the new code:
    ```bash
    docker-compose build
    ```

That's it! Your cron job will automatically start using the new version on its next run. Because your `data`, `logs`, `summaries`, and all your `.toml` configuration files are managed by `.gitignore` and Docker volumes, they are completely safe and will not be affected by the `git pull` command.

### Troubleshooting Updates

If you run `git pull` and it says "Already up to date," but you know there are new files or directories (like `images`) missing locally, your local repository might be out of sync.

**Warning:** The following commands can discard local changes to tracked files. This is generally safe for this project since all your data and configurations are untracked by Git.

#### Option 1: Restore a specific file or directory

First, try to restore just the missing item. For example, to restore the `images` directory:
```bash
git restore images
```
If this command fails with an error like `pathspec 'images' did not match any file(s) known to git`, it means the files were never actually tracked by Git in your current branch. This indicates they may have been accidentally omitted from the repository's history.

#### Option 2: Force Sync with Remote Repository

If you want to force your local repository to exactly match the remote, use the following commands. This is a more forceful approach.
```bash
# 1. Fetch the latest information from the remote repository
git fetch origin

# 2. Force your local branch to match the remote 'main' branch
git reset --hard origin/main
```

## **Note on AI Generation**

This project was created collaboratively with Google's Gemini. While the logic and functionality have been guided and tested by a human developer, much of the boilerplate code and documentation was AI-generated.
